/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const AudioStatus = {
  Ok: "ok",
  Invalid: "invalid",
  Skip: "skip",
} as const;

export type AudioStatus = (typeof AudioStatus)[keyof typeof AudioStatus];

/**
 *
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
  /**
   *
   * @type {Array<ValidationError>}
   * @memberof HTTPValidationError
   */
  detail?: Array<ValidationError>;
}
/**
 *
 * @export
 * @interface Label
 */
export interface Label {
  /**
   *
   * @type {number}
   * @memberof Label
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Label
   */
  creator: number;
  /**
   *
   * @type {number}
   * @memberof Label
   */
  sample: number;
  /**
   *
   * @type {AudioStatus}
   * @memberof Label
   */
  status: AudioStatus;
  /**
   *
   * @type {string}
   * @memberof Label
   */
  created_at: string;
  /**
   *
   * @type {Array<LabelTypeAndValue>}
   * @memberof Label
   */
  values: Array<LabelTypeAndValue>;
}

/**
 *
 * @export
 * @interface LabelCreate
 */
export interface LabelCreate {
  /**
   *
   * @type {AudioStatus}
   * @memberof LabelCreate
   */
  status: AudioStatus;
  /**
   *
   * @type {Array<LabelTypeAndValue>}
   * @memberof LabelCreate
   */
  values: Array<LabelTypeAndValue>;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const LabelType = {
  T: "t",
  G: "g",
  N: "n",
} as const;

export type LabelType = (typeof LabelType)[keyof typeof LabelType];

/**
 *
 * @export
 * @interface LabelTypeAndValue
 */
export interface LabelTypeAndValue {
  /**
   *
   * @type {LabelType}
   * @memberof LabelTypeAndValue
   */
  label_type: LabelType;
  /**
   *
   * @type {number}
   * @memberof LabelTypeAndValue
   */
  label_value: number;
}

/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Language = {
  Nv: "NV",
  En: "en",
  Cs: "cs",
} as const;

export type Language = (typeof Language)[keyof typeof Language];

/**
 *
 * @export
 * @interface LocationInner
 */
export interface LocationInner {}
/**
 * An enumeration.
 * @export
 * @enum {string}
 */

export const Role = {
  User: "user",
  Reviewer: "reviewer",
  Moderator: "moderator",
  Admin: "admin",
} as const;

export type Role = (typeof Role)[keyof typeof Role];

/**
 *
 * @export
 * @interface Sample
 */
export interface Sample {
  /**
   *
   * @type {number}
   * @memberof Sample
   */
  id: number;
  /**
   *
   * @type {number}
   * @memberof Sample
   */
  duration: number;
  /**
   *
   * @type {Language}
   * @memberof Sample
   */
  language: Language;
  /**
   *
   * @type {string}
   * @memberof Sample
   */
  created_at?: string;
  /**
   *
   * @type {number}
   * @memberof Sample
   */
  owner?: number;
  /**
   *
   * @type {number}
   * @memberof Sample
   */
  size: number;
  /**
   *
   * @type {string}
   * @memberof Sample
   */
  filename: string;
}

/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof User
   */
  name: string;
  /**
   *
   * @type {Role}
   * @memberof User
   */
  role: Role;
}

/**
 *
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserCreate
   */
  invitation_code?: string;
}
/**
 *
 * @export
 * @interface UserPasswordUpdate
 */
export interface UserPasswordUpdate {
  /**
   *
   * @type {number}
   * @memberof UserPasswordUpdate
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UserPasswordUpdate
   */
  password: string;
}
/**
 *
 * @export
 * @interface UserRoleUpdate
 */
export interface UserRoleUpdate {
  /**
   *
   * @type {number}
   * @memberof UserRoleUpdate
   */
  id: number;
  /**
   *
   * @type {Role}
   * @memberof UserRoleUpdate
   */
  role: Role;
}

/**
 *
 * @export
 * @interface UserSummary
 */
export interface UserSummary {
  /**
   *
   * @type {User}
   * @memberof UserSummary
   */
  user: User;
  /**
   *
   * @type {number}
   * @memberof UserSummary
   */
  samples_count: number;
}
/**
 *
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
  /**
   *
   * @type {Array<LocationInner>}
   * @memberof ValidationError
   */
  loc: Array<LocationInner>;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  msg: string;
  /**
   *
   * @type {string}
   * @memberof ValidationError
   */
  type: string;
}

/**
 * AudioApi - axios parameter creator
 * @export
 */
export const AudioApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Get Mp3 Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMp3AudioSampleSampleIdKeyMp3Get: async (
      sampleId: number,
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists(
        "getMp3AudioSampleSampleIdKeyMp3Get",
        "sampleId",
        sampleId
      );
      // verify required parameter 'key' is not null or undefined
      assertParamExists("getMp3AudioSampleSampleIdKeyMp3Get", "key", key);
      const localVarPath = `/sample/{sample_id}/{key}/mp3`
        .replace(`{${"sample_id"}}`, encodeURIComponent(String(sampleId)))
        .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Original Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOriginalAudioSampleSampleIdKeyAudioGet: async (
      sampleId: number,
      key: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists(
        "getOriginalAudioSampleSampleIdKeyAudioGet",
        "sampleId",
        sampleId
      );
      // verify required parameter 'key' is not null or undefined
      assertParamExists(
        "getOriginalAudioSampleSampleIdKeyAudioGet",
        "key",
        key
      );
      const localVarPath = `/sample/{sample_id}/{key}/audio`
        .replace(`{${"sample_id"}}`, encodeURIComponent(String(sampleId)))
        .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AudioApi - functional programming interface
 * @export
 */
export const AudioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AudioApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get Mp3 Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMp3AudioSampleSampleIdKeyMp3Get(
      sampleId: number,
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getMp3AudioSampleSampleIdKeyMp3Get(
          sampleId,
          key,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Original Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOriginalAudioSampleSampleIdKeyAudioGet(
      sampleId: number,
      key: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOriginalAudioSampleSampleIdKeyAudioGet(
          sampleId,
          key,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AudioApi - factory interface
 * @export
 */
export const AudioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AudioApiFp(configuration);
  return {
    /**
     *
     * @summary Get Mp3 Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMp3AudioSampleSampleIdKeyMp3Get(
      sampleId: number,
      key: string,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .getMp3AudioSampleSampleIdKeyMp3Get(sampleId, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Original Audio
     * @param {number} sampleId
     * @param {string} key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOriginalAudioSampleSampleIdKeyAudioGet(
      sampleId: number,
      key: string,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .getOriginalAudioSampleSampleIdKeyAudioGet(sampleId, key, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AudioApi - object-oriented interface
 * @export
 * @class AudioApi
 * @extends {BaseAPI}
 */
export class AudioApi extends BaseAPI {
  /**
   *
   * @summary Get Mp3 Audio
   * @param {number} sampleId
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getMp3AudioSampleSampleIdKeyMp3Get(
    sampleId: number,
    key: string,
    options?: AxiosRequestConfig
  ) {
    return AudioApiFp(this.configuration)
      .getMp3AudioSampleSampleIdKeyMp3Get(sampleId, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Original Audio
   * @param {number} sampleId
   * @param {string} key
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AudioApi
   */
  public getOriginalAudioSampleSampleIdKeyAudioGet(
    sampleId: number,
    key: string,
    options?: AxiosRequestConfig
  ) {
    return AudioApiFp(this.configuration)
      .getOriginalAudioSampleSampleIdKeyAudioGet(sampleId, key, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * LabelsApi - axios parameter creator
 * @export
 */
export const LabelsApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create Label
     * @param {number} sampleId
     * @param {LabelCreate} labelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLabelSamplesSampleIdLabelPost: async (
      sampleId: number,
      labelCreate: LabelCreate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists(
        "createLabelSamplesSampleIdLabelPost",
        "sampleId",
        sampleId
      );
      // verify required parameter 'labelCreate' is not null or undefined
      assertParamExists(
        "createLabelSamplesSampleIdLabelPost",
        "labelCreate",
        labelCreate
      );
      const localVarPath = `/samples/{sample_id}/label`.replace(
        `{${"sample_id"}}`,
        encodeURIComponent(String(sampleId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        labelCreate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Labels For Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabelsForSampleSamplesSampleIdLabelsGet: async (
      sampleId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists(
        "getLabelsForSampleSamplesSampleIdLabelsGet",
        "sampleId",
        sampleId
      );
      const localVarPath = `/samples/{sample_id}/labels`.replace(
        `{${"sample_id"}}`,
        encodeURIComponent(String(sampleId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LabelsApi - functional programming interface
 * @export
 */
export const LabelsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LabelsApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create Label
     * @param {number} sampleId
     * @param {LabelCreate} labelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLabelSamplesSampleIdLabelPost(
      sampleId: number,
      labelCreate: LabelCreate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createLabelSamplesSampleIdLabelPost(
          sampleId,
          labelCreate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Labels For Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLabelsForSampleSamplesSampleIdLabelsGet(
      sampleId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getLabelsForSampleSamplesSampleIdLabelsGet(
          sampleId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LabelsApi - factory interface
 * @export
 */
export const LabelsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LabelsApiFp(configuration);
  return {
    /**
     *
     * @summary Create Label
     * @param {number} sampleId
     * @param {LabelCreate} labelCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLabelSamplesSampleIdLabelPost(
      sampleId: number,
      labelCreate: LabelCreate,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .createLabelSamplesSampleIdLabelPost(sampleId, labelCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Labels For Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLabelsForSampleSamplesSampleIdLabelsGet(
      sampleId: number,
      options?: any
    ): AxiosPromise<Array<Label>> {
      return localVarFp
        .getLabelsForSampleSamplesSampleIdLabelsGet(sampleId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LabelsApi - object-oriented interface
 * @export
 * @class LabelsApi
 * @extends {BaseAPI}
 */
export class LabelsApi extends BaseAPI {
  /**
   *
   * @summary Create Label
   * @param {number} sampleId
   * @param {LabelCreate} labelCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public createLabelSamplesSampleIdLabelPost(
    sampleId: number,
    labelCreate: LabelCreate,
    options?: AxiosRequestConfig
  ) {
    return LabelsApiFp(this.configuration)
      .createLabelSamplesSampleIdLabelPost(sampleId, labelCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Labels For Sample
   * @param {number} sampleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LabelsApi
   */
  public getLabelsForSampleSamplesSampleIdLabelsGet(
    sampleId: number,
    options?: AxiosRequestConfig
  ) {
    return LabelsApiFp(this.configuration)
      .getLabelsForSampleSamplesSampleIdLabelsGet(sampleId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SamplesApi - axios parameter creator
 * @export
 */
export const SamplesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSampleSamplesSampleIdDelete: async (
      sampleId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists(
        "deleteSampleSamplesSampleIdDelete",
        "sampleId",
        sampleId
      );
      const localVarPath = `/samples/{sample_id}`.replace(
        `{${"sample_id"}}`,
        encodeURIComponent(String(sampleId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Next Sample For Labelling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNextSampleForLabellingSamplesNextGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/samples/next`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Own Samples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnSamplesSamplesGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/samples`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleSamplesSampleIdGet: async (
      sampleId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'sampleId' is not null or undefined
      assertParamExists("getSampleSamplesSampleIdGet", "sampleId", sampleId);
      const localVarPath = `/samples/{sample_id}`.replace(
        `{${"sample_id"}}`,
        encodeURIComponent(String(sampleId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get Samples Of User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamplesOfUserSamplesOwnerUserIdGet: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        "getSamplesOfUserSamplesOwnerUserIdGet",
        "userId",
        userId
      );
      const localVarPath = `/samples/owner/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload Sample
     * @param {string} language
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSampleSamplesPost: async (
      language: string,
      file: File,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'language' is not null or undefined
      assertParamExists("uploadSampleSamplesPost", "language", language);
      // verify required parameter 'file' is not null or undefined
      assertParamExists("uploadSampleSamplesPost", "file", file);
      const localVarPath = `/samples`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration &&
        configuration.formDataCtor) ||
        FormData)();

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      if (language !== undefined) {
        localVarFormParams.append("language", language as any);
      }

      if (file !== undefined) {
        localVarFormParams.append("file", file as any);
      }

      localVarHeaderParameter["Content-Type"] = "multipart/form-data";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SamplesApi - functional programming interface
 * @export
 */
export const SamplesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SamplesApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteSampleSamplesSampleIdDelete(
      sampleId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteSampleSamplesSampleIdDelete(
          sampleId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Next Sample For Labelling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getNextSampleForLabellingSamplesNextGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sample>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getNextSampleForLabellingSamplesNextGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Own Samples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOwnSamplesSamplesGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sample>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getOwnSamplesSamplesGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSampleSamplesSampleIdGet(
      sampleId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sample>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSampleSamplesSampleIdGet(
          sampleId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get Samples Of User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSamplesOfUserSamplesOwnerUserIdGet(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sample>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getSamplesOfUserSamplesOwnerUserIdGet(
          userId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Upload Sample
     * @param {string} language
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadSampleSamplesPost(
      language: string,
      file: File,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.uploadSampleSamplesPost(
          language,
          file,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SamplesApi - factory interface
 * @export
 */
export const SamplesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SamplesApiFp(configuration);
  return {
    /**
     *
     * @summary Delete Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteSampleSamplesSampleIdDelete(
      sampleId: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .deleteSampleSamplesSampleIdDelete(sampleId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Next Sample For Labelling
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getNextSampleForLabellingSamplesNextGet(
      options?: any
    ): AxiosPromise<Sample> {
      return localVarFp
        .getNextSampleForLabellingSamplesNextGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Own Samples
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnSamplesSamplesGet(options?: any): AxiosPromise<Array<Sample>> {
      return localVarFp
        .getOwnSamplesSamplesGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Sample
     * @param {number} sampleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSampleSamplesSampleIdGet(
      sampleId: number,
      options?: any
    ): AxiosPromise<Sample> {
      return localVarFp
        .getSampleSamplesSampleIdGet(sampleId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get Samples Of User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSamplesOfUserSamplesOwnerUserIdGet(
      userId: number,
      options?: any
    ): AxiosPromise<Array<Sample>> {
      return localVarFp
        .getSamplesOfUserSamplesOwnerUserIdGet(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload Sample
     * @param {string} language
     * @param {File} file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadSampleSamplesPost(
      language: string,
      file: File,
      options?: any
    ): AxiosPromise<number> {
      return localVarFp
        .uploadSampleSamplesPost(language, file, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SamplesApi - object-oriented interface
 * @export
 * @class SamplesApi
 * @extends {BaseAPI}
 */
export class SamplesApi extends BaseAPI {
  /**
   *
   * @summary Delete Sample
   * @param {number} sampleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public deleteSampleSamplesSampleIdDelete(
    sampleId: number,
    options?: AxiosRequestConfig
  ) {
    return SamplesApiFp(this.configuration)
      .deleteSampleSamplesSampleIdDelete(sampleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Next Sample For Labelling
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public getNextSampleForLabellingSamplesNextGet(options?: AxiosRequestConfig) {
    return SamplesApiFp(this.configuration)
      .getNextSampleForLabellingSamplesNextGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Own Samples
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public getOwnSamplesSamplesGet(options?: AxiosRequestConfig) {
    return SamplesApiFp(this.configuration)
      .getOwnSamplesSamplesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Sample
   * @param {number} sampleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public getSampleSamplesSampleIdGet(
    sampleId: number,
    options?: AxiosRequestConfig
  ) {
    return SamplesApiFp(this.configuration)
      .getSampleSamplesSampleIdGet(sampleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get Samples Of User
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public getSamplesOfUserSamplesOwnerUserIdGet(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return SamplesApiFp(this.configuration)
      .getSamplesOfUserSamplesOwnerUserIdGet(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload Sample
   * @param {string} language
   * @param {File} file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SamplesApi
   */
  public uploadSampleSamplesPost(
    language: string,
    file: File,
    options?: AxiosRequestConfig
  ) {
    return SamplesApiFp(this.configuration)
      .uploadSampleSamplesPost(language, file, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUsersPost: async (
      userCreate: UserCreate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userCreate' is not null or undefined
      assertParamExists("createUserUsersPost", "userCreate", userCreate);
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userCreate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deactivate User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateUserUsersUserIdDeactivatePatch: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists(
        "deactivateUserUsersUserIdDeactivatePatch",
        "userId",
        userId
      );
      const localVarPath = `/users/{user_id}/deactivate`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get All User Summaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserSummariesUsersSummariesGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users/summaries`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsersGet: async (
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUsersUserIdGet: async (
      userId: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists("getUserUsersUserIdGet", "userId", userId);
      const localVarPath = `/users/{user_id}`.replace(
        `{${"user_id"}}`,
        encodeURIComponent(String(userId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginAuthTokenPost: async (
      username: string,
      password: string,
      grantType?: string,
      scope?: string,
      clientId?: string,
      clientSecret?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'username' is not null or undefined
      assertParamExists("loginAuthTokenPost", "username", username);
      // verify required parameter 'password' is not null or undefined
      assertParamExists("loginAuthTokenPost", "password", password);
      const localVarPath = `/auth/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (grantType !== undefined) {
        localVarFormParams.set("grant_type", grantType as any);
      }

      if (username !== undefined) {
        localVarFormParams.set("username", username as any);
      }

      if (password !== undefined) {
        localVarFormParams.set("password", password as any);
      }

      if (scope !== undefined) {
        localVarFormParams.set("scope", scope as any);
      }

      if (clientId !== undefined) {
        localVarFormParams.set("client_id", clientId as any);
      }

      if (clientSecret !== undefined) {
        localVarFormParams.set("client_secret", clientSecret as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Password
     * @param {UserPasswordUpdate} userPasswordUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasswordUsersPasswordPatch: async (
      userPasswordUpdate: UserPasswordUpdate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userPasswordUpdate' is not null or undefined
      assertParamExists(
        "updatePasswordUsersPasswordPatch",
        "userPasswordUpdate",
        userPasswordUpdate
      );
      const localVarPath = `/users/password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userPasswordUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update Role
     * @param {UserRoleUpdate} userRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoleUsersRoleUpdatePatch: async (
      userRoleUpdate: UserRoleUpdate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userRoleUpdate' is not null or undefined
      assertParamExists(
        "updateRoleUsersRoleUpdatePatch",
        "userRoleUpdate",
        userRoleUpdate
      );
      const localVarPath = `/users/role_update`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PATCH",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication LoginManager required
      // oauth required
      await setOAuthToObject(
        localVarHeaderParameter,
        "LoginManager",
        [],
        configuration
      );

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUserUsersPost(
      userCreate: UserCreate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.createUserUsersPost(
          userCreate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Deactivate User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deactivateUserUsersUserIdDeactivatePatch(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deactivateUserUsersUserIdDeactivatePatch(
          userId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get All User Summaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUserSummariesUsersSummariesGet(
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<UserSummary>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUserSummariesUsersSummariesGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllUsersUsersGet(
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getAllUsersUsersGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserUsersUserIdGet(
      userId: number,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getUserUsersUserIdGet(userId, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async loginAuthTokenPost(
      username: string,
      password: string,
      grantType?: string,
      scope?: string,
      clientId?: string,
      clientSecret?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.loginAuthTokenPost(
          username,
          password,
          grantType,
          scope,
          clientId,
          clientSecret,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update Password
     * @param {UserPasswordUpdate} userPasswordUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePasswordUsersPasswordPatch(
      userPasswordUpdate: UserPasswordUpdate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updatePasswordUsersPasswordPatch(
          userPasswordUpdate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Update Role
     * @param {UserRoleUpdate} userRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRoleUsersRoleUpdatePatch(
      userRoleUpdate: UserRoleUpdate,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateRoleUsersRoleUpdatePatch(
          userRoleUpdate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration);
  return {
    /**
     *
     * @summary Create User
     * @param {UserCreate} userCreate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUserUsersPost(
      userCreate: UserCreate,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .createUserUsersPost(userCreate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deactivate User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateUserUsersUserIdDeactivatePatch(
      userId: number,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .deactivateUserUsersUserIdDeactivatePatch(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get All User Summaries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserSummariesUsersSummariesGet(
      options?: any
    ): AxiosPromise<Array<UserSummary>> {
      return localVarFp
        .getAllUserSummariesUsersSummariesGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get All Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUsersUsersGet(options?: any): AxiosPromise<Array<User>> {
      return localVarFp
        .getAllUsersUsersGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get User
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserUsersUserIdGet(userId: number, options?: any): AxiosPromise<User> {
      return localVarFp
        .getUserUsersUserIdGet(userId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Login
     * @param {string} username
     * @param {string} password
     * @param {string} [grantType]
     * @param {string} [scope]
     * @param {string} [clientId]
     * @param {string} [clientSecret]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    loginAuthTokenPost(
      username: string,
      password: string,
      grantType?: string,
      scope?: string,
      clientId?: string,
      clientSecret?: string,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .loginAuthTokenPost(
          username,
          password,
          grantType,
          scope,
          clientId,
          clientSecret,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Password
     * @param {UserPasswordUpdate} userPasswordUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePasswordUsersPasswordPatch(
      userPasswordUpdate: UserPasswordUpdate,
      options?: any
    ): AxiosPromise<any> {
      return localVarFp
        .updatePasswordUsersPasswordPatch(userPasswordUpdate, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update Role
     * @param {UserRoleUpdate} userRoleUpdate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoleUsersRoleUpdatePatch(
      userRoleUpdate: UserRoleUpdate,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .updateRoleUsersRoleUpdatePatch(userRoleUpdate, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   *
   * @summary Create User
   * @param {UserCreate} userCreate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public createUserUsersPost(
    userCreate: UserCreate,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .createUserUsersPost(userCreate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deactivate User
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deactivateUserUsersUserIdDeactivatePatch(
    userId: number,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .deactivateUserUsersUserIdDeactivatePatch(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get All User Summaries
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getAllUserSummariesUsersSummariesGet(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getAllUserSummariesUsersSummariesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get All Users
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getAllUsersUsersGet(options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getAllUsersUsersGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get User
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUserUsersUserIdGet(userId: number, options?: AxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUserUsersUserIdGet(userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login
   * @param {string} username
   * @param {string} password
   * @param {string} [grantType]
   * @param {string} [scope]
   * @param {string} [clientId]
   * @param {string} [clientSecret]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public loginAuthTokenPost(
    username: string,
    password: string,
    grantType?: string,
    scope?: string,
    clientId?: string,
    clientSecret?: string,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .loginAuthTokenPost(
        username,
        password,
        grantType,
        scope,
        clientId,
        clientSecret,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Password
   * @param {UserPasswordUpdate} userPasswordUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updatePasswordUsersPasswordPatch(
    userPasswordUpdate: UserPasswordUpdate,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updatePasswordUsersPasswordPatch(userPasswordUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update Role
   * @param {UserRoleUpdate} userRoleUpdate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateRoleUsersRoleUpdatePatch(
    userRoleUpdate: UserRoleUpdate,
    options?: AxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateRoleUsersRoleUpdatePatch(userRoleUpdate, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
